<!---
	NumPy・SciPyを用いた数値計算の高速化 : 応用その2
-->

# 対象
Python及びNumPy初心者に向けて書いています. 「C言語は使えるけど最近Pythonを始めた」とか「Pythonらしい書き方がよくわからない」に該当する物理系の数値計算を目的とした方には特に有用かもしれません.

また, 自分の不勉強のために間違った記述があるかもしれません. ご容赦ください. 

# あらまし
[NumPyを用いた数値計算の高速化 : 基礎](http://qiita.com/jabberwocky0139/items/c3620fb2f011f20a633b)

[NumPy・SciPyを用いた数値計算の高速化 : 応用その1](http://qiita.com/jabberwocky0139/items/a9751d11caa64bc19226)

の続きになります. 基礎的な数値計算の手法を追っていきますが, 今回は少し発展的な内容も含みます. 

# 超越方程式
随分大仰な名前ですが, 代数的な手法で解けない方程式のことを指します. 具体的には

$$
\sin(x) = \frac{x}{2}
$$
こんな子です. この方程式は, 「$\sin(x)$を知るためには$\frac{x}{2}$が必要で, $\frac{x}{2}$を知るには$\sin(x)$が必要」という構造を持っているため, 「自己無撞着(self-consistent)方程式」とも呼ばれます. 代数的に解けなくても数値的に解くことはもちろん可能です. アルゴリズムは「Newton法」や「二分法」が挙げられます. アルゴリズムの詳細は省略しますが, そんなに難しくないので知らない方は調べてみてください. これらの実装は単純ですが, 結局は逐次代入をしているようなものなのでforループの使用が避けられません. Newton法だと基本的に収束は速いのですが, 微分可能な関数であることが条件で, 性質の良い関数が要求されます. 一方で2分法は指定した区間に解があれば必ず見つけることができますが, 収束までの反復回数は多くなります. 

ただ, もうお気づきかもしれませんが, これらは`scipy.optimize`というモジュールに既に実装してあります. forループ云々は関数の中で完結しており, 高速に動作してくれます. 

## 実装

上の方程式の解がだいたいどこにあるのかを確認します:

![](images/figure5.png)

だいたい$x = 1.5 - 2.0$の間にあることがわかりますね. これを二分法で解いてあげます:

```py3
from scipy.optimize import bisect
def f(x):
	return np.sin(x) - x/2
	
bisect(f, 1.5, 2) 
>>> 1.895494267034337
```
非常にシンプルです. 区間内に解が2つ以上あるとどちらに収束するかわからないので, 必ず1つになるようにしましょう. もちろん代数的に解ける方程式でも使えます. 

# Fourier変換
Fourier変換と言えば信号処理などでおなじみですが, 今回も物理の話で進めさせて頂きます. 少し数学的な話が多くなりますがご了承ください. 前の記事で扱った拡散方程式を思い出してください:

$$
\frac{\partial}{\partial t}f(x, t) = \frac{\partial^2}{\partial x^2}f(x, t)
$$
この子はFourier変換で解いてあげることができるのでした. その方法を見ていきましょう. Fourier変換と逆Fourier変換を以下のように定義します:

$$
\tilde{f}(k, t) = \frac{1}{\sqrt{2\pi}}\int dx e^{-ikx}f(k, t) = {\cal F}[f(x, t)]\\
f(x, t) = \frac{1}{\sqrt{2\pi}}\int dk e^{ikx}\tilde{f}(k, t) = {\cal F}^{-1}[\tilde{f}(k, t)]
$$
この定義を拡散方程式に代入してみましょう. すると, $x$微分が実行できてしまいます:

$$
\frac{\partial}{\partial t}\left(\frac{1}{\sqrt{2\pi}}\int dk e^{ikx}\tilde{f}(k, t)\right) = \frac{\partial^2}{\partial x^2}\left(\frac{1}{\sqrt{2\pi}}\int dk e^{ikx}\tilde{f}(k, t)\right)\\
\frac{\partial}{\partial t}\left(\frac{1}{\sqrt{2\pi}}\int dk e^{ikx}\tilde{f}(k, t)\right) = -\left(\frac{1}{\sqrt{2\pi}}\int dk k^2e^{ikx}\tilde{f}(k, t)\right)\\
$$
さらに$k$積分を外すと単なる$t$に関する1階微分方程式になっているので, 簡単に解いてあげることができます:

$$
\frac{\partial}{\partial t}\tilde{f}(k, t) = -k^2\tilde{f}(k, t)\\
\tilde{f}(k, t) = e^{-k^2 t}\tilde{f}(k, 0)
$$
そしてこれを逆Fourier変換してあげます:

$$
\frac{1}{\sqrt{2\pi}}\int dk e^{ikx}\tilde{f}(k, t) = \frac{1}{\sqrt{2\pi}}\int dk e^{ikx}e^{-k^2 t}\tilde{f}(k, 0)\\
f(x, t) = \frac{1}{\sqrt{2\pi}}\int dk e^{ikx}e^{-k^2 t}\tilde{f}(k, 0)
$$
$\tilde{f}$のままだとよくわからないので, $f$に直してあげます:

$$
f(x, t) = \frac{1}{2\pi}\int dk e^{ikx}e^{-k^2 t}\int dx' e^{-ikx'}f(x', 0)
$$
もし初期条件$f(x, 0)$の式がわかっており, かつそれが解析的に積分できるものであれば[^1]解析解が求まります. もし解析的に積分不可能であればやはり数値的に解くありません. 

さて, この流れをシンプルに書くと以下のようになります:

$$
f(x, t) = {\cal F}^{-1}[e^{-k^2 t}{\cal F}[f(x, 0)]]
$$
$f(x, 0)$をFourier変換した後, $e^{-k^2 t}$を掛けて逆Fourier変換すればよいのです. これの素晴らしいところは, **$x$や$t$を差分化していないところです. ** 以前のような差分化を用いた方法だと, 微分を差分に置き換えることが基本なので, 差分の幅が小さいことが絶対条件でした. しかし, 今回ははじめに$x$や$f(x)$を差分化するものの, **$\Delta x$のオーダーが計算結果に効いてくることはありません. ** $t$はそもそも差分化していません. つまり, $t$の時間をどんどん進めていっても誤差が蓄積しません. これはけっこう凄いことです. 

さて, 最後に問題になるのが, $k$とはなにかということです. ある$N$個に差分化された$x_i$に対して$k_i$がどんな値を取るのでしょうか？これは$x_i$の離散Fourier変換について真面目に考えればわかりますが, 

$$
k_i = 
\begin{cases}
2\pi\frac{i}{N}\hspace{0.5cm} (0 \le i < N/2)\\
2\pi\frac{N-i}{N}\hspace{0.5cm} (N/2 \le i < N)
\end{cases}
$$
となっています. これは少しややこしいですね. **しかし, SciPyはこの$k_i$を生成する関数まで用意しています. ** なんとも周到ですね. 

## 実装
長々とお話してしまいましたが, コーディングはシンプルです. Fourier変換は`scipy.fftpack`に用意されています. 

注意点は2点あります. 

* 離散Fourier変換の仕様上, 分割数は2の累乗が好ましいです. 

* `fft`を噛ませて$k$空間に移ると`complex`型を経由するので, `ifft`をかけて$x$空間に戻しても虚部のゴミが残ってしまいます. `real`だけを取るか`abs`を取るようにしましょう. 


```py3
from scipy.fftpack import fft, ifft, fftfreq

def f(x):
    return np.exp(-x**2)

# set system
N, L = 256, 40.0
x = np.linspace(-L/2, L/2, N)

# set initial function
gaussian = f(x)
plt.plot(x, gaussian, label="t=0")

# set k_i
k = 2 * np.pi * fftfreq(N, d=1/N)/L
time = [2, 4, 8]

for t in time:
    expK = np.exp(-k**2 * t)
    result = ifft(fft(gaussian) * expK)
```
for文がありますがそこはご愛嬌...こういう時間ステップはしょうがないです. 今回は3回しか回してないですし. ただ, 注意したいのは**2s→4s→8sのように逐次時間を進めているのではなく, それぞれ独立に時間発展を計算しているということです. **つまり, 8sのグラフが欲しければ, `t=8`を代入するだけで良いのです. ここが差分法との最大の違いです. 

![](images/figure6.png)

前回と同じグラフが得られましたね. この方法は非常に強力でポテンシャルがある場合などにも応用でき, トロッター分解を用いたSymplectic法などに発展していきます...が, 専門的過ぎるのでここまでにしておきましょう. 

# 非線形微分方程式(発展)
この内容はちょっと専門的です. 興味がなければスルーして頂いて結構ですが, 少し大事な話も含みます. 

物理ではしばしば非線形微分方程式が出てきます. そんなある非線形方程式[^2]

$$
\left(-\frac{1}{2}\frac{d^2}{dx^2} + g|\psi(x)|\right)\psi(x) = 0
$$
があったとします. これは今までの方法で解くことは難しそうです. なぜなら**差分化したときに行列の中に$\psi(x)$を含むから**です. 具体的には

$$
\left[
\frac{1}{2\Delta x^2}
	\begin{pmatrix}
	-2&1&0&\cdots&0\\ 
	1&-2 &1&&0\\
	0 & 1&-2&& \vdots\\
	\vdots&&&\ddots&1\\
	0& \cdots& 0 &1& -2
\end{pmatrix}
+g
\begin{pmatrix}
	|\psi_0|^2&0&0&\cdots&0\\ 
	0&|\psi_1|^2 &0&&0\\
	0 & 0&|\psi_2|^2&& \vdots\\
	\vdots&&&\ddots&0\\
	0& \cdots& 0 &0& |\psi_n|^2
\end{pmatrix}
\right]
\begin{pmatrix}
\psi_0\\
\psi_1\\
\vdots\\
\psi_{n-1}\\
\psi_n
\end{pmatrix}
= T(\psi)\psi
=0
$$
これは$T\psi$のような線形作用素で書くことができないということであり, これが「非線形」ということばのひとつの解釈です. 上では無理やり行列で書いていますが, $T(\psi)\psi$になってしまいます. $\psi$を求めたいのに, それを求めるために必要な行列が$\psi$を含んでいるという構造ですね. これを自己無撞着的と呼ぶのでした. 

さて, ここでちょっと以下のような固有値方程式を考えてみます:

$$
T(\psi)\psi = E_n \psi
$$
この固有値方程式の$E_i = 0$に相当するのが元の微分方程式です. これを用いたアイデアが以下のとおりです:

* **この非線形微分方程式を満たす特解の形がある程度わかっていたとき, その解に近い$\psi$を使って$T(\psi)$をつくり, 固有値方程式を解く.**

* **得られた固有値の中で, 絶対値が最も小さいもの($E_i = 0$に近いもの)に対応する固有ベクトルは非線形微分方程式の解に近いものだと考えられる[^4].**

* **その固有ベクトルで再び$T(\psi)$をつくり固有値方程式を解く...ということを繰り返した結果, $\psi$の形が変わらなくなったときにこれは元の微分方程式の解になっている.**

そして, 上の非線形方程式にはソリトン解と呼ばれるものが存在し, その中でもブライトソリトンと呼ばれるものはガウシアンに似ています[^3]. というわけで, $\psi$の初期関数にガウシアンを選んでこのアイデアを実装してみましょう. 

## 実装


[^1]: 正確には「$f$が解析的に積分可能」のではなく「$f$が解析的にFourier変換可能」が条件. 

[^2]: Gross-Pitaevskii方程式と呼ばれています. 

[^3]: 似てはいるものの, ガウシアンとは全く異なる性質を持ちます. 

[^4]: だと思ったのですが, どうやらそう単純ではありませんでした. 固有値のインデックスが一番小さいものが1ソリトン, 2番目が2ソリトン...のように対応している
