<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<!---
    NumPy・SciPyを用いた数値計算の高速化 : 応用その2
-->
<h1 id="対象">対象</h1>
<p>Python及びNumPy初心者に向けて書いています. 「C言語は使えるけど最近Pythonを始めた」とか「Pythonらしい書き方がよくわからない」に該当する物理系の数値計算を目的とした方には特に有用かもしれません.</p>
<p>また, 自分の不勉強のために間違った記述があるかもしれません. ご容赦ください.</p>
<h1 id="あらまし">あらまし</h1>
<p><a href="http://qiita.com/jabberwocky0139/items/c3620fb2f011f20a633b">NumPyを用いた数値計算の高速化 : 基礎</a></p>
<p><a href="http://qiita.com/jabberwocky0139/items/a9751d11caa64bc19226">NumPy・SciPyを用いた数値計算の高速化 : 応用その1</a></p>
<p>の続きになります. 基礎的な数値計算の手法を追っていきますが, 今回は少し発展的な内容も含みます.</p>
<h1 id="超越方程式">超越方程式</h1>
<p>随分大仰な名前ですが, 代数的な手法で解けない方程式のことを指します. 具体的には</p>
<p><span class="math display">\[
\sin(x) = \frac{x}{2}
\]</span> こんな子です. この方程式は, 「<span class="math inline">\(\sin(x)\)</span>を知るためには<span class="math inline">\(\frac{x}{2}\)</span>が必要で, <span class="math inline">\(\frac{x}{2}\)</span>を知るには<span class="math inline">\(\sin(x)\)</span>が必要」という構造を持っているため, 「自己無撞着(self-consistent)方程式」とも呼ばれます. 代数的に解けなくても数値的に解くことはもちろん可能です. アルゴリズムは「Newton法」や「二分法」が挙げられます. アルゴリズムの詳細は省略しますが, そんなに難しくないので知らない方は調べてみてください. これらの実装は単純ですが, 結局は逐次代入をしているようなものなのでforループの使用が避けられません. Newton法だと基本的に収束は速いのですが, 微分可能な関数であることが条件で, 性質の良い関数が要求されます. 一方で2分法は指定した区間に解があれば必ず見つけることができますが, 収束までの反復回数は多くなります.</p>
<p>ただ, もうお気づきかもしれませんが, これらは<code>scipy.optimize</code>というモジュールに既に実装してあります. forループ云々は関数の中で完結しており, 高速に動作してくれます.</p>
<h2 id="実装">実装</h2>
<p>上の方程式の解がだいたいどこにあるのかを確認します:</p>
<div class="figure">
<img src="images/figure5.png" />

</div>
<p>だいたい<span class="math inline">\(x = 1.5 - 2.0\)</span>の間にあることがわかりますね. これを二分法で解いてあげます:</p>
<pre class="py3"><code>from scipy.optimize import bisect
def f(x):
    return np.sin(x) - x/2
    
bisect(f, 1.5, 2) 
&gt;&gt;&gt; 1.895494267034337</code></pre>
<p>非常にシンプルです. 区間内に解が2つ以上あるとどちらに収束するかわからないので, 必ず1つになるようにしましょう. もちろん代数的に解ける方程式でも使えます.</p>
<h1 id="fourier変換">Fourier変換</h1>
<p>Fourier変換と言えば信号処理などでおなじみですが, 今回も物理の話で進めさせて頂きます. 少し数学的な話が多くなりますがご了承ください. 前の記事で扱った拡散方程式を思い出してください:</p>
<p><span class="math display">\[
\frac{\partial}{\partial t}f(x, t) = \frac{\partial^2}{\partial x^2}f(x, t)
\]</span> この子はFourier変換で解いてあげることができるのでした. その方法を見ていきましょう. Fourier変換と逆Fourier変換を以下のように定義します:</p>
<p><span class="math display">\[
\tilde{f}(k, t) = \frac{1}{\sqrt{2\pi}}\int dx e^{-ikx}f(k, t) = {\cal F}[f(x, t)]\\
f(x, t) = \frac{1}{\sqrt{2\pi}}\int dk e^{ikx}\tilde{f}(k, t) = {\cal F}^{-1}[\tilde{f}(k, t)]
\]</span> この定義を拡散方程式に代入してみましょう. すると, <span class="math inline">\(x\)</span>微分が実行できてしまいます:</p>
<p><span class="math display">\[
\frac{\partial}{\partial t}\left(\frac{1}{\sqrt{2\pi}}\int dk e^{ikx}\tilde{f}(k, t)\right) = \frac{\partial^2}{\partial x^2}\left(\frac{1}{\sqrt{2\pi}}\int dk e^{ikx}\tilde{f}(k, t)\right)\\
\frac{\partial}{\partial t}\left(\frac{1}{\sqrt{2\pi}}\int dk e^{ikx}\tilde{f}(k, t)\right) = -\left(\frac{1}{\sqrt{2\pi}}\int dk k^2e^{ikx}\tilde{f}(k, t)\right)\\
\]</span> さらに<span class="math inline">\(k\)</span>積分を外すと単なる<span class="math inline">\(t\)</span>に関する1階微分方程式になっているので, 簡単に解いてあげることができます:</p>
<p><span class="math display">\[
\frac{\partial}{\partial t}\tilde{f}(k, t) = -k^2\tilde{f}(k, t)\\
\tilde{f}(k, t) = e^{-k^2 t}\tilde{f}(k, 0)
\]</span> そしてこれを逆Fourier変換してあげます:</p>
<p><span class="math display">\[
\frac{1}{\sqrt{2\pi}}\int dk e^{ikx}\tilde{f}(k, t) = \frac{1}{\sqrt{2\pi}}\int dk e^{ikx}e^{-k^2 t}\tilde{f}(k, 0)\\
f(x, t) = \frac{1}{\sqrt{2\pi}}\int dk e^{ikx}e^{-k^2 t}\tilde{f}(k, 0)
\]</span> <span class="math inline">\(\tilde{f}\)</span>のままだとよくわからないので, <span class="math inline">\(f\)</span>に直してあげます:</p>
<p><span class="math display">\[
f(x, t) = \frac{1}{2\pi}\int dk e^{ikx}e^{-k^2 t}\int dx&#39; e^{-ikx&#39;}f(x&#39;, 0)
\]</span> もし初期条件<span class="math inline">\(f(x, 0)\)</span>の式がわかっており, かつそれが解析的に積分できるものであれば<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>解析解が求まります. もし解析的に積分不可能であればやはり数値的に解くありません.</p>
<p>さて, この流れをシンプルに書くと以下のようになります:</p>
<p><span class="math display">\[
f(x, t) = {\cal F}^{-1}[e^{-k^2 t}{\cal F}[f(x, 0)]]
\]</span> <span class="math inline">\(f(x, 0)\)</span>をFourier変換した後, <span class="math inline">\(e^{-k^2 t}\)</span>を掛けて逆Fourier変換すればよいのです. これの素晴らしいところは, <strong><span class="math inline">\(x\)</span>や<span class="math inline">\(t\)</span>を差分化していないところです. </strong> 以前のような差分化を用いた方法だと, 微分を差分に置き換えることが基本なので, 差分の幅が小さいことが絶対条件でした. しかし, 今回ははじめに<span class="math inline">\(x\)</span>や<span class="math inline">\(f(x)\)</span>を差分化するものの, <strong><span class="math inline">\(\Delta x\)</span>のオーダーが計算結果に効いてくることはありません. </strong> <span class="math inline">\(t\)</span>はそもそも差分化していません. つまり, <span class="math inline">\(t\)</span>の時間をどんどん進めていっても誤差が蓄積しません. これはけっこう凄いことです.</p>
<p>さて, 最後に問題になるのが, <span class="math inline">\(k\)</span>とはなにかということです. ある<span class="math inline">\(N\)</span>個に差分化された<span class="math inline">\(x_i\)</span>に対して<span class="math inline">\(k_i\)</span>がどんな値を取るのでしょうか？これは<span class="math inline">\(x_i\)</span>の離散Fourier変換について真面目に考えればわかりますが,</p>
<p><span class="math display">\[
k_i = 
\begin{cases}
2\pi\frac{i}{N}\hspace{0.5cm} (0 \le i &lt; N/2)\\
2\pi\frac{N-i}{N}\hspace{0.5cm} (N/2 \le i &lt; N)
\end{cases}
\]</span> となっています. これは少しややこしいですね. <strong>しかし, SciPyはこの<span class="math inline">\(k_i\)</span>を生成する関数まで用意しています. </strong> なんとも周到ですね.</p>
<h2 id="実装-1">実装</h2>
<p>長々とお話してしまいましたが, コーディングはシンプルです. Fourier変換は<code>scipy.fftpack</code>に用意されています.</p>
<p>注意点は2点あります.</p>
<ul>
<li><p>離散Fourier変換の仕様上, 分割数は2の累乗が好ましいです.</p></li>
<li><p><code>fft</code>を噛ませて<span class="math inline">\(k\)</span>空間に移ると<code>complex</code>型を経由するので, <code>ifft</code>をかけて<span class="math inline">\(x\)</span>空間に戻しても虚部のゴミが残ってしまいます. <code>real</code>だけを取るか<code>abs</code>を取るようにしましょう.</p></li>
</ul>
<pre class="py3"><code>from scipy.fftpack import fft, ifft, fftfreq

def f(x):
    return np.exp(-x**2)

# set system
N, L = 256, 40.0
x = np.linspace(-L/2, L/2, N)

# set initial function
gaussian = f(x)
plt.plot(x, gaussian, label=&quot;t=0&quot;)

# set k_i
k = 2 * np.pi * fftfreq(N, d=1/N)/L
time = [2, 4, 8]

for t in time:
    expK = np.exp(-k**2 * t)
    result = ifft(fft(gaussian) * expK)</code></pre>
<p>for文がありますがそこはご愛嬌...こういう時間ステップはしょうがないです. 今回は3回しか回してないですし. ただ, 注意したいのは<strong>2s→4s→8sのように逐次時間を進めているのではなく, それぞれ独立に時間発展を計算しているということです. </strong>つまり, 8sのグラフが欲しければ, <code>t=8</code>を代入するだけで良いのです. ここが差分法との最大の違いです.</p>
<div class="figure">
<img src="images/figure6.png" />

</div>
<p>前回と同じグラフが得られましたね. この方法は非常に強力でポテンシャルがある場合などにも応用でき, トロッター分解を用いたSymplectic法などに発展していきます...が, 専門的過ぎるのでここまでにしておきましょう.</p>
<h1 id="非線形微分方程式発展">非線形微分方程式(発展)</h1>
<p>この内容はちょっと専門的です. 興味がなければスルーして頂いて結構ですが, 少し大事な話も含みます.</p>
<p>物理ではしばしば非線形微分方程式が出てきます. そんなある非線形方程式<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p><span class="math display">\[
\left(-\frac{1}{2}\frac{d^2}{dx^2} + g|\psi(x)|\right)\psi(x) = \mu\psi(x)
\]</span> があったとします. これは今までの方法で解くことは難しそうです. なぜなら<strong>差分化したときに行列の中に<span class="math inline">\(\psi(x)\)</span>を含むから</strong>です. 具体的には</p>
<p><span class="math display">\[
\left[
\frac{1}{2\Delta x^2}
    \begin{pmatrix}
    -2&amp;1&amp;0&amp;\cdots&amp;0\\ 
    1&amp;-2 &amp;1&amp;&amp;0\\
    0 &amp; 1&amp;-2&amp;&amp; \vdots\\
    \vdots&amp;&amp;&amp;\ddots&amp;1\\
    0&amp; \cdots&amp; 0 &amp;1&amp; -2
\end{pmatrix}
+g
\begin{pmatrix}
    |\psi_0|^2&amp;0&amp;0&amp;\cdots&amp;0\\ 
    0&amp;|\psi_1|^2 &amp;0&amp;&amp;0\\
    0 &amp; 0&amp;|\psi_2|^2&amp;&amp; \vdots\\
    \vdots&amp;&amp;&amp;\ddots&amp;0\\
    0&amp; \cdots&amp; 0 &amp;0&amp; |\psi_n|^2
\end{pmatrix}
\right]
\begin{pmatrix}
\psi_0\\
\psi_1\\
\vdots\\
\psi_{n-1}\\
\psi_n
\end{pmatrix}
= T(\psi)\psi
=\mu\psi
\]</span> これは<span class="math inline">\(T\psi\)</span>のような線形作用素で書くことができないということであり, これが「非線形」ということばのひとつの解釈です. 上では無理やり行列で書いていますが, <span class="math inline">\(T(\psi)\psi\)</span>になってしまいます. <span class="math inline">\(\psi\)</span>を求めたいのに, それを求めるために必要な行列が<span class="math inline">\(\psi\)</span>を含んでいるという構造ですね. これを自己無撞着的と呼ぶのでした.</p>
<p>さて, ここで上の微分方程式を<span class="math inline">\(\mu\)</span>を固有値とした固有値方程式と見立ててあげます:</p>
<p><span class="math display">\[
T(\psi)\psi = \mu_n \psi
\]</span> 自己無撞着方程式であることから以下のようなアイデアが浮かびます:</p>
<ul>
<li><p><strong>この非線形微分方程式を満たす特解の形がある程度わかっていたとき, その解に近い<span class="math inline">\(\psi\)</span>を使って<span class="math inline">\(T(\psi)\)</span>をつくり, 固有値方程式を解く.</strong></p></li>
<li><p><strong>得られた固有ベクトルの中で, 今求めようとしているものに一番近いものを選ぶ.</strong></p></li>
<li><p><strong>その固有ベクトルで再び<span class="math inline">\(T(\psi)\)</span>をつくり固有値方程式を解く...ということを繰り返した結果, <span class="math inline">\(\psi\)</span>の形が変わらなくなったときにこれは元の微分方程式の解になっており, そのときの<span class="math inline">\(\mu\)</span>の値も同時に決定される.</strong></p></li>
</ul>
<p>そして, 上の非線形方程式にはソリトン解と呼ばれるものが存在し, その中でも<span class="math inline">\(g &lt; 0\)</span>のときにはブライトソリトンと呼ばれるガウシアンに似た<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>特解が存在します. というわけで, <span class="math inline">\(\psi\)</span>の初期関数にガウシアンを選んでこのアイデアを実装してみましょう.</p>
<h2 id="実装-2">実装</h2>
<pre class="py3"><code>def h(x):
    return x * np.exp(-x**2)

# set system
L, N, g = 30, 200, -5
x, dx = np.linspace(-L/2, L/2, N), L / N

# set K matrix
K = np.eye(N, N)
K_sub = np.vstack((K[1:], np.array([0] * N)))
K = (dx**-2 * (2 * K - K_sub - K_sub.T)) * 0.5

# set initial parameter
v, w, mu = np.array([h(x)]).reshape(N, 1), np.array([3]), 0

# self-consistent loop
while abs(w[np.argmin(w)] - mu) &gt; 1e-5:

    # update mu
    mu = w[np.argmin(w)]
    
    # set G matrix
    G = g * np.diag(np.abs(v.T[np.argmin(w)])**2)
    
    # solve
    T = K + G
    w, v = np.linalg.eigh(T)</code></pre>
<p>今回は繰り返す関数に<span class="math inline">\(v.T[0]\)</span>を選びました. 今回の微分方程式では一番低いエネルギー固有関数に1ソリトンが対応しているようです<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. 収束条件は<span class="math inline">\(\mu\)</span>に課しています. このぐらいの制度で, 16回ほどループしていました. これをプロットしてみましょう:</p>
<div class="figure">
<img src="images/figure7.png" />

</div>
<p>ソリトンっぽいですが, ガウシアンでないかが不安です. 試しにソリトンの一般解</p>
<p><span class="math display">\[
f_s(x) = \frac{b}{a\cosh(x)}
\]</span> でフィッティングしてみましょう:</p>
<pre class="py3"><code>from scipy.optimize import curve_fit

def bright_soliton(x, a, b):
    return (b / np.cosh(a * x))**2
    
param = curve_fit(bright_soliton, x, v.T[0]**2)[0]</code></pre>
<div class="figure">
<img src="images/figure8.png" alt="ぴったり一致しました. 恐らくソリトンで間違いないでしょう." />
<p class="caption">ぴったり一致しました. 恐らくソリトンで間違いないでしょう.</p>
</div>
<p>ちょっと小難しい話が続きましたが, 今回重要なのはソリトン云々ではなく, 自己無撞着方程式のような<strong>値を変えつつ行列を初期化して計算を繰り返すようなコードにおいては, いちいち初期化にループを用いていると大変な時間がかかるだろうということです.</strong> 自己無撞着ループ + 行列の初期化2ループ = 3ループみたいなことをやっているともうたいへんです. こういうアルゴリズムをPythonで相手にするにはNumPyが不可欠なのです. 以前の<a href="http://qiita.com/jabberwocky0139/items/c3620fb2f011f20a633b">基礎編</a>で書いた「巨大な行列をパラメータを変えるごとに都度初期化して計算を進めるようなタスクでは, 大きな威力を発揮します」とは今回のような計算を指すのでした.</p>
<h1 id="さいごに-個人的なこと">さいごに / 個人的なこと</h1>
<p>基礎的な数値計算の実装についてお話ししてきました. これ以上はやや専門的になるかと思うのでここまでとします. あとは自分がやりたい計算に合わせてNumPy・SciPyのリファレンスを見ていただけると良いかと思います. とは言いつつも, 少し語り残したこともあるのでまた別記事にまとめるかもしれません.</p>
<p>そもそもこの記事を書こうと思った動機は, この手の高速化に関する情報があまりネット上に無いなあと感じていたからです. 自分は以下のような道を辿ってきました.</p>
<ol style="list-style-type: decimal">
<li><p>Pythonのシンプルな仕様と数値計算のライブラリの豊富さに感動. 自分の研究にも使いたいが, C++のコードをそのまま落とし込むと非常に遅い. ハードな数値計算に対応できないのだろうか？と模索を始める.</p></li>
<li><p>「NumPyが高速だ！」という話は至るところでされていますが, Cから移行してきた人は結局for/while文を使ってしまいます. NumPy配列をfor文に渡すという愚行を犯し, 「ぜんぜん早くないじゃないか！」と思っていました. 今考えると滑稽ですね.</p></li>
<li><p>「for文が遅い！」という話もまた各方面でされていますが, Cから移行してきた人はfor/while文を使わずにどうやって数値計算のコードを書けばよいのかがわからないです. 確かに行列演算は高速なのでしょうが, 行列以外の計算はどうなのか, その行列をどうやって用意するか等々悩みが尽きませんでした.</p></li>
<li><p>「リスト内包は普通のfor文より速い！」とも言われますが, 正直微々たる差でした.</p></li>
<li><p>そして行き着く先がCython, Boost/Python, Numbaなどでした. これらのツールは確かに高速にはなるものの制約が多く, 高速化に目を向けるほどCライクなコードに豹変していきます.</p></li>
<li><p>結果「C++でよくない？」となるわけです. しかしPythonに慣れた身ではC++の難解な言語仕様に嫌気が差してしまいます.</p></li>
<li><p>5.に戻る</p></li>
</ol>
<p>...ということを1年近く繰り返していました. NumPyのマニュアルを読めばそれぞれの関数の使い方はわかりますが, ハードな数値計算にも耐えうる, つまりfor文を極力使わない数値アルゴリズムの解説はあまり見当たらなかったように思います.</p>
<p>今の自分が「はじめからこれがわかっていれば...」と思うことをまとめたつもりです. 数値計算の実行速度に悩む方々の助けになれば幸いです.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>正確には「<span class="math inline">\(f\)</span>が解析的に積分可能」のではなく「<span class="math inline">\(f\)</span>が解析的にFourier変換可能」が条件.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Gross-Pitaevskii方程式と呼ばれています.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>似てはいるものの, ガウシアンとは全く異なる性質を持ちます.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>解くモデルごとに変わる可能性は十分あり, 試行錯誤が必要かもしれません.<a href="#fnref4">↩</a></p></li>
</ol>
</div>
</body>
</html>
